# Лабораторная 2

## Задания для лабораторной

#### Обычная:

1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов

2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены

3. В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат

4. В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

#### Со звездочкой:

Написать “плохой” Docker compose файл, в котором есть не менее трех “bad practices” по их написанию

Написать “хороший” Docker compose файл, в котором эти плохие практики исправлены

В Readme описать каждую из плохих практик в плохом файле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат

После предыдущих пунктов в хорошем файле настроить сервисы так, чтобы контейнеры в рамках этого compose-проекта так же поднимались вместе, но не "видели" друг друга по сети. В отчете описать, как этого добились и кратко объяснить принцип такой изоляции

## Выполнение лабораторной

### Обычная:

Для начала нам нужно установить Docker и разобраться, как он работает. К счастью, он бесплатный и к тому же предлагает инструкцию, разобравшись с которой можно понять, что вообще от нас требуется. Создадим простенький html-файл, который будет запускаться на веб-странице и приступим к написанию dockerfile’ов.

**Плохой докерфайл:**

```
FROM python

RUN apt-get update 
RUN pip install numpy

COPY . .

EXPOSE 8084

CMD [“python3” “-m” “http.server” “8084”]
```

С помощью написанного нами докерфайла можно собрать и запустить контейнер.

Тут мы его собираем:

![ ](/photos-for-readme/image1.jpg)

Тут мы его запускаем (не стоит забывать про указание портов, тут можно застрять на час гугла, не зная, в чем вообще проблема):

Как видно, даже очень лаконичные и не очень правильные докерфайлы работают.


**Использованные плохие практики:**

1. ```FROM```

В плохом докерфайле может быть не указана версия вызываемого образа или указана последняя (```:latest```), что может в дальнейшем сломать код, если, например, выйдут несовместимые обновления. Поэтому лучше указывать конкретную версию.

2. ```RUN```

Не стоит использовать несколько ```RUN```, потому что каждый из них создает слой в образе, что может перегрузить программу. Лучше будет запустить несколько команд в одном ```RUN``` через &&.

Также стоит обратить внимание на похожую на предыдущую ошибку – отсутствие версии у библиотеки ```numpy```. Стоит установить конкретную версию по тем же причинам, что и у ```python``` в пункте 1.

3. ```WORKDIR```

Отсутствие WORKDIR не сломает файл, потому что в таком случае директорией будет считаться эта же директория, но стоит указать, с чем мы вообще работаем, чтобы не запутаться. В [документации](https://docs.docker.com/reference/dockerfile/#workdir) написано, что можно указать путь к директории через ENV, что может быть полезно для больших файлов, однако для нашего достаточно просто указать директорию, с которой мы будем работать. Еще можно, кстати, определить рабочий каталог относительно контейнера с помощью ```WORKDIR /myapp```.

4. ```COPY```

Не стоит копировать все содержимое директории, если мы знаем, какие конкретно файлы нам надо скопировать. Там может лежать вообще все что угодно, и мы сильно перегрузим программу. 

5. ```USER```

Мы не указываем пользователя, поэтому процесс выполняется с ```root```, к которому доступ может получить любой человек, а значит, у нас серьезные проблемы с безопасностью. Хорошо, что мы только смотрим на картинки с дельфинами, но пусть на них смотрит только пользователь ```app_user```.

Не совсем ошибка, но фанфакт: если скопировать приведенный выше код и вставить его в докерфайл, он не запустится. Можно потратить часа два на поиск ошибки, а лучше сыграть в игру “Найди отличие”.
```
CMD [“python3”, “-m”, “http.server”, “8084”]
CMD ["python3", "-m", "http.server", "8084"]
```

Дети, не копируйте кавычки из текстового редактора.

**Хороший докерфайл:**
```
FROM python:3.12.16

RUN apt-get update && useradd app_user && pip install numpy==2.1.1

WORKDIR /Users/riapankova/Documents/docker-project/bad-dockerfile

COPY index.html .
COPY dolphins.jpeg .

USER app_user

EXPOSE 8085

CMD ["python3", "-m", "http.server", "8085"]

```

На основе всех минусов были исправлены ошибки (и даже кавычки!). Теперь соберем и запустим и его.

Дельфины рады.

**Плохие практики работы с контейнерами в целом:**

1. Использование важных данных в контейнерах

Контейнеры не предназначены для хранения данных, их можно запустить, остановить и удалить, когда они больше не нужны. Если об этом забыть и держать в контейнере базу данных, например, можно легко потерять вообще всю информацию.

2. Запуск одного контейнера для нескольких приложений

Не стоит держать в одном докерфайле сразу веб-сервер и базу данных. Забегая вперед, отметим, что docker-compose подходит сильно больше для этого, а простой докерфайл может и перегрузиться (это, кстати, тоже проблема: стоит ограничивать ресурсы для контейнеров, потому что они могут перегрузить сервер – при запуске можно использовать ограничения), и его контролировать будет сильно сложнее, так как приложения будет не разделить. А если одно из приложений сломается, придется отключать и те, которые стабильно работают. Проще избавить себя от головной боли и выделить под каждое приложение свой контейнер.

### Со звездочкой

**Плохой docker compose файл:**

```
version: '3'

services:
 web:
   build:
     context: .
     dockerfile: Dockerfile
   ports:
     - "8084:8084"

 db:
   image: postgres
   environment:
     POSTGRES_DB: mydb
     POSTGRES_USER: user
     POSTGRES_PASSWORD: password

```

**Плохие практики:**

1. Отсутствие указания версии

Как и в обычной лабе, снова проблема в неуказанной версии, на этот раз это ```postgres```. В хорошем файле укажем версию.

2. Хранение конфиденциальных данных в коде:

Тут есть юзер бд, однако все данные хранятся прямо в файле, что очень небезопасно. Стоит создать переменные окружения, через которые передадим важные данные. Это еще и удобно, потому что не надо каждый раз редактировать сам код.

3. Зависимости

Веб-серверу стоит подождать, пока запустится база данных, чтобы не случилось сбоя. Добавим зависимости (```depends on```).

**Хороший docker compose файл:**
```
version: '3.8'

services:
 web_app:
   build:
     context: .
     dockerfile: Dockerfile
   ports:
     - "8085:8085"
   networks:
     - web_network
   depends_on:
     - database

 database:
   image: postgres:13
   environment:
     POSTGRES_DB: ${POSTGRES_DB}
     POSTGRES_USER: ${POSTGRES_USER}
     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
   networks:
     - db_network
   volumes:
     - db_data:/var/lib/postgresql/data

networks:
 web_network:
 db_network:

volumes:
 db_data:
```

Тут еще и добавлен пункт 4. Контейнеры изолированы в сети ```networks```, которые объявляются в каждом контейнере, чтобы они не мешали друг другу и друг друга не видели. Это более безопасно, чем общая сеть для всех компонентов.

Запускается это все с помощью команды ```docker compose up```.


Вот так вот все процессы выглядят внутри приложения Docker Desktop. Интересно, что если не выдавать контейнеру имя, докер придумывает что-то забавное!

